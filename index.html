<!DOCTYPE html>
<meta charset="utf-8">

<div id="chart"></div>
<style>
body {
    font: 10px Arial;
	
}

.view {
  fill: rgba(255, 255, 255, 0.2);
}

.axis path {
  display: none;
}

.axis line {
  stroke-opacity: 0.3;
}

.line {
    fill: none;
    stroke: #ffab00;
    stroke-width: 2px;
}

.contextline {
    fill: none;
    stroke: #ffab00;
    stroke-width: 1px;
}

.zoom {
    fill: none;
    pointer-events: all;
}

.reset {
  position: absolute;
  top: 20px;
  left: 80px;
}

.autoscale {
  position: absolute;
  top: 60px;
  left: 80px;
}

</style>
<body>

<script src="https://d3js.org/d3.v4.min.js"></script>

<button onclick="resetted()" class="reset">Reset</button>
<div class="autoscale">
  <input type="checkbox" name="myCheckBox" checked>
  <label for="myCheckBox">Autoscale Y</label>
</div>
<div id="dataviz_buttonTriger"></div>

<svg width="1000" height="600"></svg>
<script>

var nMaxPts = 500;
//var margin = {top: 20, right: 20, bottom: 50, left: 50},
//    margin2 = {top: 20, right: 20, bottom: 30, left: 40},
//    width = +svg.attr("width") - margin.left - margin.right,
//    height = +svg.attr("height") - margin.top - margin.bottom;

var svg = d3.select("svg"), 
    margin = {top: 20, right: 20, bottom: 110, left: 40},
    margin2 = {top: 430, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom-10;

var parseTime = d3.timeParse("%Y-%m-%dT%H:%M:%S");
	bisectDate = d3.bisector(function(d) { return d.Timestamp; }).left;
	formatValue = d3.format(",.2f"),
    formatCurrency = function(d) { return formatValue(d) + "Â°"; };
	
var x = d3.scaleTime().range([0, width]),
    x2 = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var line = d3.line()
    .defined(function(d) { return d.Temperature != 0; })
    .x(function (d) { return x(d.Timestamp); })
    .y(function (d) { return y(d.Temperature); })
    .curve(d3.curveMonotoneX);

var line2 = d3.line()
    .x(function (d) { return x2(d.Timestamp); })
    .y(function (d) { return y2(d.Temperature); });

svg = d3.select('#chart')
    .append("svg:svg")
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append("svg:g")
	.attr("id","group")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//var clip = svg.append("defs").append("svg:clipPath")
//    .attr("id", "clip")
//    .append("svg:rect")
//    .attr("width", width)
//    .attr("height", height)
//    .attr("x", 0)
//    .attr("y", 0); 

    var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);	

    var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);
	
	var xAxis = d3.axisBottom(x)
		.ticks((width + 2) / (height + 2) * 5)
		.tickSize(-height)
		.tickPadding(10);

    var xAxis2 = d3.axisBottom(x2);
//		.ticks((width + 2) / (height2 + 2) * 5)
//		.tickSize(-height2)
//		.tickPadding(10);
			
	var yAxis = d3.axisRight(y)
		.ticks(5)
		.tickSize(width)
		.tickPadding(- 20 - width);

	var view = svg.append("rect")
		.attr("class", "view")
		.attr("x", 0.5)
		.attr("y", 0.5)
		.attr("width", width - 1)
		.attr("height", height - 1);

	var chartBody = svg.append("g")
        .attr("class", "focus")
		.attr("clip-path", "url(#clip)");

    var focus = svg.append("g") 
        .attr("class", "focus")
        //.style("display", "none")
        //.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var context = svg.append("g")
        .attr("class", "context")
        .attr("transform", "translate(" + 0 + "," + margin2.top + ")");

    var tip = svg.append("g") 
        .attr("class", "tip")
        .style("display", "none")

var dataperm;
var dataslice;

// Get the data
d3.csv("rpi.node", function(error, data) {
	if (error) throw error;
	
    dataperm = data;

    dataslice = reduceArray( dataperm, [0,dataperm.length], nMaxPts );

	// format the data
	data.forEach(function(d,i) {
		d.Timestamp = parseTime(d.Timestamp);
		d.Temperature = +d.Temperature;
	});

	// Scale the range of the data
	//console.log("Date range: ", d3.extent(data, function(d) { return d.Timestamp; }));
	//console.log("Price range: ", d3.extent(data, function(d) { return +d.Temperature; }));	
	x.domain(d3.extent(dataslice, function(d) { return d.Timestamp; }));
	y.domain([d3.min(dataslice, function (d) { return d.Temperature; })-5, d3.max(dataslice, function (d) { return d.Temperature; })+5]);
    
    x2.domain(x.domain());
    y2.domain(y.domain());	

	focus.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);

	focus.append("g")
		.attr("class", "axis axis--y")
		.call(yAxis);

    context.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

	chartBody.append("path")
		.datum(dataslice)
		.attr("class", "line")
		.attr("d", line);

    context.append("path")
        .datum(dataslice)
        .attr("class", "contextline")
        .attr("d", line2);

    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x.range());
		
	svg.append("defs").append("clipPath")
		.attr("id", "clip")
	    .append("rect")
		.attr("width", width)
		.attr("height", height);

	svg.append("text")             
	  .attr("transform",
			"translate(" + (width/2) + " ," + (height + margin.top + 20) + ")")
	  .style("font-size","12px")
	  .style("font-family", "sans-serif")
	  .style("text-anchor", "middle")
	  .text("Date/Time");
	  
	svg.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", 0 - margin.left/1)
		  .attr("x",0 - (height / 2))
		  .attr("dy", "1em")
		  .style("font-size","12px")
		  .style("text-anchor", "middle")
		  .text("Temperature");

	tip.append("circle")
		.attr("class", "y")
		.style("fill", "none")
		.style("stroke", "steelblue")
		.attr("r", 4)
		.attr("clip-path", "url(#clip)");	
		
	tip.append("text")
        .attr("class", "y")
		.attr("dy", ".35em")
  		.attr("clip-path", "url(#clip)");

	svg.append("rect")
		.attr("id","rect")
        .attr("class", "zoom")
		.attr("width", width)
		.attr("height", height)
        //.style("fill", "none")
        //.style("pointer-events", "all")
        .on("mouseover", function() { tip.style("display", null); })
        .on("mouseout", function() { tip.style("display", "none"); })
        .on("mousemove", mousemove)
        .call(zoom);
		
	focus.append("g")
		  .attr("transform", "translate(0," + height + ")")
		  .call(d3.axisBottom(x).ticks(0));
		  
	focus.append("g")
	  .call(d3.axisLeft(y).ticks(0));

	 
	//d3.select("#rect").call(zoom);
	
	//d3.select("button").on("click", resetted);

    // update chart to hold only the visible data (for performance reasons)
    //chartBody.select(".line").attr("d", line(dataslice.slice(0,1000)));
    //context.select(".contextline").attr("d", line(dataslice));
    //y2.domain(y.domain());
    //gX.call(xAxis.scale(x2));

});

	function mouseDate(scale) {
		var g = d3.select("#group")._groups[0][0];
		var x0 = scale.invert(d3.mouse(g)[0]);  // d3.mouse(g)[0] ... relative x-pos in main line chart
		var i = bisectDate(dataslice, x0, 1);
        i = Math.min(...[i, dataslice.length-1]);	
		var d = x0 - dataslice[i-1].date > dataslice[i].date - x0 ? dataslice[i] : dataslice[i-1];
	    return d;
	}
	
	function mousemove() {
		//var transform = d3.zoomTransform(this);
		//var xt = transform.rescaleX(x2); //, yt = transform.rescaleY(y);
        //console.log(x.domain())
		d = mouseDate(x);
		tip.select("circle.y")
			.attr('cx', function() {
									return x(d.Timestamp);
								})
			.attr('cy', function() {
									return y(d.Temperature);
								});

		tip.select("text.y")
			 .text(formatCurrency(d.Temperature))
			 .attr('x', function() {
									return x(d.Timestamp)+10;
			 })
			 .attr('y', function() {
			 						return y(d.Temperature);
			 });
	}
	
	function zoomed() {
        // ignore zoom-by-brush
	    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; 

	  //gX.call(xAxis.scale(d3.event.transform.rescaleX(x2)));
	  //gY.call(yAxis.scale(d3.event.transform.rescaleY(y)));
	  //var t = d3.event.transform, xt = t.rescaleX(x); //, yt = t.rescaleY(y)

	  //chartBody.select(".line")
      //         .attr("d",line.x(function(d) { return xt(d.Timestamp);})
      //         .y(function(d) { return y(d.Temperature);}));
        
//chartBody.select(".line").attr("d", line(data));

        var t = d3.event.transform;
  
        x.domain(t.rescaleX(x2).domain());

        //console.log(x.domain())

        var domain = x.domain();
        var drange = [ dataperm.findIndex(d => d.Timestamp.getTime() > domain[0].getTime()), 
                       dataperm.findIndex(d => d.Timestamp.getTime() >= domain[1].getTime()) ];
        
        if ( (drange[1]-drange[0]) > nMaxPts ) {
            dataslice = reduceArray( dataperm, drange, nMaxPts );

        } else {
            dataslice = dataperm.slice(drange[0], drange[1]);
        }
        chartBody.select(".line").attr("d", line(dataslice));

		//d = mouseDate(x);
        // update mouseover circle and text position while zoomed
		tip.select("circle.y")
			 .classed("zoomed", true)
			 .attr("id","one")
			 .attr('cx', function() {return t.applyX(x2(d.Timestamp)); })
			 .attr('cy', function() {return y(d.Temperature); });				
		tip.select("text.y")
			 .text(formatCurrency(d.Temperature))
			 .attr('x', function() {return t.applyX(x2(d.Timestamp))+10;})
			 .attr('y', function() {return y(d.Temperature); });

        // update x-axis
        focus.select(".axis--x").call(xAxis);
        // update context area
        context.select(".brush").call(brush.move, x.range().map(t.invertX, t));

    }

	function brushed() {
        // ignore brush-by-zoom
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; 
        
        // re-map domain of x-axis
        var s = d3.event.selection || x2.range();
        x.domain(s.map(x2.invert, x2));
          //chartBody.select(".line").attr("d", line);
        
        // 
        svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
            .scale(width / (s[1] - s[0]))
            .translate(-s[0], 0));

        var domain = x.domain();    

        //console.log(x.domain())

        var drange = [ dataperm.findIndex(d => d.Timestamp.getTime() > domain[0].getTime()), 
                       dataperm.findIndex(d => d.Timestamp.getTime() >= domain[1].getTime()) ];
      
        if ( (drange[1]-drange[0]) > nMaxPts ) {
            dataslice = reduceArray( dataperm, drange, nMaxPts );
        } else {
            dataslice = dataperm.slice(drange[0], drange[1]);
        }

        //update chart to hold only the visible data (for performance reasons)
        chartBody.select(".line").attr("d", line(dataslice));

        //gX.call(xAxis.scale(x2));
        focus.select(".axis--x").call(xAxis);
	}
	
	function resetted() {
	  d3.select("#rect").transition()
		  .duration(750)
		  .call(zoom.transform, d3.zoomIdentity);
	}

function linSpace(startValue, stopValue, cardinality) {
  var arr = [];
  var step = (stopValue - startValue) / (cardinality - 1);
  for (var i = 0; i < cardinality; i++) {
    arr.push(startValue + (step * i));
  }
  return arr;
}

function getTemp( array ) {
  var tarray = [];
  for (var i=0; i < array.length; i=i+1) {
    tarray[i] = parseFloat(array[i].Temperature);
  }
  return tarray;
}

const arrAvg = arr => arr.reduce((a,b) => a + b, 0) / arr.length

function reduceArray( data, drange, nPts ) {
    var ind = linSpace( drange[0], drange[1], nPts );

    // TODO: duplicate indices
    ind = ind.map(function(element){
        return Math.round(element);
        });

    var rdata = [];
    for (i = 0; i < ind.length-1; i=i+1) {
      // using max has performance advantage?
      //var tavg = arrAvg( getTemp(data.slice(ind[i],ind[i+1])) );
      var tavg = Math.max(...getTemp(data.slice(ind[i],ind[i+1])) );
      var el = {Timestamp: data[ind[i]].Timestamp, 
                Temperature: tavg,
                Humidity: "n/a"};
      rdata.push(data[ind[i]]);  
      //rdata.push(el);  zooming creates less fluctuation using this, but cannot be used in context initialization
    }
    return rdata;
}

</script>
</body>
