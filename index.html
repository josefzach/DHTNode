<!DOCTYPE html>
<meta charset="utf-8">

<!div id="chart"><!/div>

<style>
body {
    font: 10px Arial; 
}

.view {
    fill: rgba(255, 255, 255, 0.2);
}

.axis path {
    display: none;
}

.axis line {
    stroke-opacity: 0.3;
}

.line {
    fill: none;
    stroke: #ffab00;
    stroke-width: 2px;
    stroke-opacity: 0.5;
}

.line_humidity {
    fill: none;
    stroke: #b700ff;
    stroke-width: 2px;
    stroke-opacity: 0.5;
}

.contextline {
    fill: none;
    stroke: #ffab00;
    stroke-width: 1px;
}

.zoom {
    fill: none;
    pointer-events: all;
}

.reset {
    position: absolute;
}

.autoscale {
    position: absolute;
}

</style>

<body>

<script src="https://d3js.org/d3.v4.min.js"></script>

<button id="reset" class="reset" onclick="resetted()">Reset</button>
<div id="autoscale" class="autoscale">
    <input type="checkbox" id="myCheckBox" name="myCheckBox" onclick="on_checkbox()" checked>
    <label for="myCheckBox">Autoscale Y</label>
</div>

<!div id="dataviz_buttonTriger"><!/div>

<svg width="1000" height="600"></svg>

<script>

var nMaxPts = 100;
//var margin = {top: 20, right: 20, bottom: 50, left: 50},
//    margin2 = {top: 20, right: 20, bottom: 30, left: 40},
//    width = +svg.attr("width") - margin.left - margin.right,
//    height = +svg.attr("height") - margin.top - margin.bottom;

var isChecked = true;

var svg = d3.select("svg"),
    focusHeight = +svg.attr("height") * 0.7,
    contextHeight = +svg.attr("height") - focusHeight;
    totalWidth = +svg.attr("width"),
    margin = {top: 20, right: 20, bottom: contextHeight, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    margin2 = {top: focusHeight+30, right: 20, bottom: 40, left: 40},
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;

var svg = d3.select("svg")
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append("svg:g")
    .attr("id","group")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var parseTime = d3.timeParse("%Y-%m-%dT%H:%M:%S");
    bisectDate = d3.bisector(function(d) { return d.Timestamp; }).left;
    formatValue = d3.format(",.2f"),
    formatTemperature = function(d) { return formatValue(d) + "Â°"; };
    
var x = d3.scaleTime().range([0, width]),
    x2 = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var line = d3.line()
    .defined(function(d) { return d.Temperature != 0; })
    .x(function (d) { return x(d.Timestamp); })
    .y(function (d) { return y(d.Temperature); })
    .curve(d3.curveMonotoneX);

var line_humidity = d3.line()
    .defined(function(d) { return d.Humidity != 0; })
    .x(function (d) { return x(d.Timestamp); })
    .y(function (d) { return y(d.Humidity); })
    .curve(d3.curveMonotoneX);
    
var line2 = d3.line()
    .x(function (d) { return x2(d.Timestamp); })
    .y(function (d) { return y2(d.Temperature); })
    .curve(d3.curveMonotoneX);

//svg = d3.select('#chart')
//    .append("svg:svg")
//    .attr('width', width + margin.left + margin.right)
//    .attr('height', height + margin.top + margin.bottom)
//    .append("svg:g")
//    .attr("id","group")
//    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//var clip = svg.append("defs").append("svg:clipPath")
//    .attr("id", "clip")
//    .append("svg:rect")
//    .attr("width", width)
//    .attr("height", height)
//    .attr("x", 0)
//    .attr("y", 0); 

var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);    

var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);
    
var xAxis = d3.axisBottom(x)
    .ticks((width + 2) / (height + 2) * 5)
    .tickSize(-height)
    .tickPadding(10);

var xAxis2 = d3.axisBottom(x2);
//        .ticks((width + 2) / (height2 + 2) * 5)
//        .tickSize(-height2)
//        .tickPadding(10);
            
var yAxis = d3.axisRight(y)
    .ticks(5)
    .tickSize(width)
    .tickPadding(- 20 - width);

var yAxisRight = d3.axisLeft(y)
    .ticks(5)
    .tickSize(width)
    .tickPadding(- 20 - width);
        
var view = svg.append("rect")
    .attr("class", "view")
    .attr("x", 0.5)
    .attr("y", 0.5)
    .attr("width", width - 1)
    .attr("height", height - 1);

var chartBody = svg.append("g")
    .attr("class", "focus")
    .attr("clip-path", "url(#clip)");

var focus = svg.append("g") 
    .attr("class", "focus")
    //.style("display", "none")
    //.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + 0 + "," + margin2.top + ")");

var tip = svg.append("g") 
    .attr("class", "tip")
    .style("display", "none")

document.getElementById("reset").style.visibility = "hidden";
document.getElementById("autoscale").style.visibility = "hidden";

var dataperm;
var dataslice;

//var rbtn = document.getElementById('reset'); 
//    rbtn.setAttribute('style', 'top:100px;left:150px;');

// Get the data
d3.csv("rpi.node", function(error, data) {
    if (error) throw error;
    
    dataperm = data;

    //dataslice = reduceArray( dataperm, [0,dataperm.length], nMaxPts );
    console.log(dataperm);

    // format the data
    dataperm.forEach(function(d,i) {
        d.Timestamp = parseTime(d.Timestamp);
        d.Temperature = +20*d.Temperature;
    });

    // Scale the range of the data
    //console.log("Date range: ", d3.extent(data, function(d) { return d.Timestamp; }));
    //console.log("Price range: ", d3.extent(data, function(d) { return +d.Temperature; }));    
    x.domain(d3.extent(dataperm, function(d) { return d.Timestamp; }));
    y.domain(getYRange(dataperm));
    
    x2.domain(x.domain());
    y2.domain(y.domain());    

    focus.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

    focus.append("g")
        .attr("class", "axis axis--y")
        .attr("transform", "translate(" + width + ",0)")
        .call(yAxisRight);
        
    context.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

    chartBody.append("path")
        .datum(dataperm)
        .attr("class", "line")
        .attr("d", line);
    
    chartBody.append("path")
        .datum(dataperm)
        .attr("class", "line_humidity")
        .attr("d", line_humidity);
        
    context.append("path")
        .datum(reduceArray( dataperm, [0,dataperm.length], nMaxPts ))
        .attr("class", "contextline")
        .attr("d", line2);

    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x.range());
        
    svg.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);

    svg.append("text")             
        .attr("transform", "translate(" + (width/2) + " ," + (height + margin.top + 20) + ")")
        .style("font-size","12px")
        .style("font-family", "sans-serif")
        .style("text-anchor", "middle")
        .text("Date/Time");
      
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left/1)
        .attr("x",0 - (height / 2))
        .attr("dy", "1em")
        .style("font-size","12px")
        .style("text-anchor", "middle")
        .text("Temperature");

    tip.append("circle")
        .attr("class", "y")
        .style("fill", "none")
        .style("stroke", "steelblue")
        .attr("r", 4)
        .attr("clip-path", "url(#clip)");    
        
    tip.append("text")
        .attr("class", "y")
        .attr("dy", ".35em")
          .attr("clip-path", "url(#clip)");

    svg.append("rect")
        .attr("id","rect")
        .attr("class", "zoom")
        .attr("width", width)
        .attr("height", height)
        //.style("fill", "none")
        //.style("pointer-events", "all")
        .on("mouseover", function() { tip.style("display", null); })
        .on("mouseout", function() { tip.style("display", "none"); })
        .on("mousemove", mousemove)
        .call(zoom);

// inactive if rect above is enabled
var lineOpacity = "0.25";
var lineOpacityHover = "0.85";
var otherLinesOpacityHover = "0.1";
var lineStroke = "1.5px";
var lineStrokeHover = "2.5px";

var circleOpacity = '0.85';
var circleOpacityOnLineHover = "0.25"
var circleRadius = 3;
var circleRadiusHover = 6;

    chartBody.select(".line")
        .on("mouseover", function(d) {
            console.log("MOUSEOVER");
            d3.selectAll('.line')
                .style('opacity', otherLinesOpacityHover);
            d3.selectAll('.circle')
                .style('opacity', circleOpacityOnLineHover);
            d3.select(this)
                .style('opacity', lineOpacityHover)
                .style("stroke-width", lineStrokeHover)
                .style("cursor", "pointer");
        })
        .on("mouseout", function(d) {
            d3.selectAll(".line")
                .style('opacity', lineOpacity);
            d3.selectAll('.circle')
                .style('opacity', circleOpacity);
            d3.select(this)
                .style("stroke-width", lineStroke)
                .style("cursor", "none");
        });
        
    // plot x-axis
    focus.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x).ticks(0));
          
    // plot y-axis lhs
    focus.append("g")
        .call(d3.axisLeft(y).ticks(0));

    // plot y-axis rhs
    focus.append("g")
        .attr("transform", "translate(0" + width + ",0)")
        .call(d3.axisRight(y).ticks(0));
  
        
    document.getElementById("reset").style.visibility = "";
    document.getElementById("reset").style.top = "30px";
    document.getElementById("reset").style.left = totalWidth-100+"px";

    document.getElementById("autoscale").style.visibility = "";
    document.getElementById("autoscale").style.top = "60px";
    document.getElementById("autoscale").style.left = totalWidth-100+"px";

    //d3.select("#rect").call(zoom);
    
    //d3.select("button").on("click", resetted);

    // update chart to hold only the visible data (for performance reasons)
    //chartBody.select(".line").attr("d", line(dataslice.slice(0,1000)));
    //context.select(".contextline").attr("d", line(dataslice));
    //y2.domain(y.domain());
    //gX.call(xAxis.scale(x2));

});

function mouseDate(scale) {
    var g = d3.select("#group")._groups[0][0];
    var x0 = scale.invert(d3.mouse(g)[0]);  // d3.mouse(g)[0] ... relative x-pos in main line chart
    var i = bisectDate(dataslice, x0, 1);
    i = Math.min(...[i, dataslice.length-1]);    
    var d = x0 - dataslice[i-1].Timestamp > dataslice[i].Timestamp - x0 ? dataslice[i] : dataslice[i-1];
    return [d, d3.mouse(g)];
}

function mousemove() {
    //var transform = d3.zoomTransform(this);
    //var xt = transform.rescaleX(x2); //, yt = transform.rescaleY(y);
    //console.log(x.domain())
    [d,mxy] = mouseDate(x);
    tip.select("circle.y")
        .attr('cx', function() {
                                return x(d.Timestamp);
                            })
        .attr('cy', function() {
                                return y(d.Temperature);
                            });

    tip.select("text.y")
         .text(formatTemperature(d.Temperature))
         .attr('x', function() {
                                return x(d.Timestamp)+10;
         })
         .attr('y', function() {
                                 return y(d.Temperature);
         });
    
    if( getXYDist(getXYData(dataslice),mxy)[1] < 20 ) {   
        console.log("CLOSE");
        d3.selectAll('.line')
            .style('opacity', 0.6);
        d3.selectAll('.circle')
            .style('opacity', 0.6);
        d3.select(this)
            .style('opacity', 0)
            .style("stroke-width", 5)
            .style("cursor", "pointer");
    } else {
        console.log("FAR");
        d3.selectAll('.line')
            .style('opacity', 0.2);
        d3.selectAll('.circle')
            .style('opacity', 0.2);
        d3.select(this)
            .style('opacity', 0.2)
            .style("stroke-width", 2)
            .style("cursor", "pointer");    
    }
}

function zoomed() {
    // ignore zoom-by-brush
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; 

  //gX.call(xAxis.scale(d3.event.transform.rescaleX(x2)));
  //gY.call(yAxis.scale(d3.event.transform.rescaleY(y)));
  //var t = d3.event.transform, xt = t.rescaleX(x); //, yt = t.rescaleY(y)

  //chartBody.select(".line")
  //         .attr("d",line.x(function(d) { return xt(d.Timestamp);})
  //         .y(function(d) { return y(d.Temperature);}));
    
//chartBody.select(".line").attr("d", line(data));

    var t = d3.event.transform;

    x.domain(t.rescaleX(x2).domain());

    //console.log(x.domain())

    var domain = x.domain();
    var drange = [ dataperm.findIndex(d => d.Timestamp.getTime() > domain[0].getTime()), 
                   dataperm.findIndex(d => d.Timestamp.getTime() >= domain[1].getTime()) ];
    
    if ( (drange[1]-drange[0]) > nMaxPts ) {
        dataslice = reduceArray( dataperm, drange, nMaxPts );

    } else {
        dataslice = dataperm.slice(drange[0], drange[1]);
    }
    chartBody.select(".line").attr("d", line(dataslice));

    if ( isChecked == true ) {
        y.domain(getYRange(dataslice));
    } 

    //d = mouseDate(x);
    // update mouseover circle and text position while zoomed
    tip.select("circle.y")
        .classed("zoomed", true)
        .attr("id","one")
        .attr('cx', function() {return x(d.Timestamp); })
        .attr('cy', function() {return y(d.Temperature); });                
    tip.select("text.y")
        .text(formatTemperature(d.Temperature))
        .attr('x', function() {return x(d.Timestamp)+10;})
        .attr('y', function() {return y(d.Temperature); });

    // update x-axis
    focus.select(".axis--x").call(xAxis);
    focus.select(".axis--y").call(yAxis);
    // update context area
    context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
    
    //xydat = svg.select(".line").attr("d");
    //console.log(xydat);
}

function brushed() {
    // ignore brush-by-zoom
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; 
    
    // re-map domain of x-axis
    var s = d3.event.selection || x2.range();
    x.domain(s.map(x2.invert, x2));
      //chartBody.select(".line").attr("d", line);
    
    // 
    svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
        .scale(width / (s[1] - s[0]))
        .translate(-s[0], 0));

    var domain = x.domain();    

    //console.log(x.domain())

    var drange = [ dataperm.findIndex(d => d.Timestamp.getTime() > domain[0].getTime()), 
                   dataperm.findIndex(d => d.Timestamp.getTime() >= domain[1].getTime()) ];
  
    if ( (drange[1]-drange[0]) > nMaxPts ) {
        dataslice = reduceArray( dataperm, drange, nMaxPts );
    } else {
        dataslice = dataperm.slice(drange[0], drange[1]);
    }

    //update chart to hold only the visible data (for performance reasons)
    chartBody.select(".line").attr("d", line(dataslice));

    if ( isChecked == true ) {
        y.domain(getYRange(dataslice));
    } 

    //gX.call(xAxis.scale(x2));
    focus.select(".axis--x").call(xAxis);
    focus.select(".axis--y").call(yAxis);
}

function resetted() {
    d3.select("#rect").transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity);
}

function on_checkbox() {
    // Get the checkbox
    var checkBox = document.getElementById("myCheckBox");
    // Get the output text
    var text = document.getElementById("text");

    // If the checkbox is checked, display the output text
    if (checkBox.checked == true){
        isChecked = true;
        y.domain(getYRange(dataslice));
        // update plot
        chartBody.select(".line").attr("d", line(dataslice));
    } else {
        isChecked = false;
    }
}

function linSpace(startValue, stopValue, cardinality) {
    var arr = [];
    var step = (stopValue - startValue) / (cardinality - 1);
    for (var i = 0; i < cardinality; i++) {
        arr.push(startValue + (step * i));
    }
    return arr;
}

function getTemp( array ) {
    var tarray = [];
    for (var i=0; i < array.length; i=i+1) {
        tarray[i] = parseFloat(array[i].Temperature);
    }
    return tarray;
}

const arrAvg = arr => arr.reduce((a,b) => a + b, 0) / arr.length

function reduceArray( data, drange, nPts ) {
    var ind = linSpace( drange[0], drange[1], nPts );

    // return copy of original array if less than nPts datapoints
    if ((drange[1]-drange[0]) <= nPts) {
        return [...data]
    }
    
    // TODO: duplicate indices
    ind = ind.map(function(element){
        return Math.round(element);
        });

    var rdata = [];
    var el;//, el2;
    //var rdata2 = [];
    for (i = 0; i < ind.length-1; i=i+1) {
        // using max has performance advantage?
        //var tavg = arrAvg( getTemp(data.slice(ind[i],ind[i+1])) );
        var tavg = Math.max(...getTemp(data.slice(ind[i],ind[i+1])) );
        //el = {Timestamp: data[ind[i]].Timestamp, 
        //          Temperature: tavg,
        //          Humidity: "n/a"};
        el = {...data[ind[i]]};
        //console.log(el);
        //el = jQuery.extend(true, {}, data[ind[i]]);
        //el = data[ind[i]];
        //console.log(el);
        el.Temperature = tavg;      
        rdata.push(el);
        //rdata[i].Temperature = tavg; 
        //rdata2.push(el2);  //zooming creates less fluctuation using this, but cannot be used in context initialization
    }
    //console.log(rdata);
    //console.log(rdata2);
    return rdata;
}

function getYRange( data ){
    return [d3.min(data, function (d) { return d.Temperature; })-5, d3.max(data, function (d) { return d.Temperature; })+5];
}

function getXYData( data ){
    var xyarray = [];
    data.forEach(d => xyarray.push([x(d.Timestamp),y(d.Temperature)]));
    return xyarray;
}

function getXYDist( xyarray, mxy ){
    var xydist = [];
    var max = 1e100;
    var dist;
    var maxind;
    xyarray.forEach(function(d,index) {
        dist = Math.sqrt( Math.pow(d[0]-mxy[0],2) + Math.pow(d[1]-mxy[1],2) );
        if ( dist < max ){
            max = dist;
            maxind = index;
        }
        xydist.push( dist );
    });
    return [xydist, max, maxind];
}

</script>
</body>
